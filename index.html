<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tetris — Simple Working</title>
<style>
  :root{
    --pink: #ff89d9;
    --accent: #ff00aa;
    --panel-dark: #1e1e1e;
    --panel-light: #f6f6f6;
    --bg-dark: #0b0b0b;
    --bg-light: #ffffff;
  }
  html,body{
    height:100%;
    margin:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background: var(--bg-dark);
    font-family: "Segoe UI", system-ui, Arial;
  }
  #wrap{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:8px;
    padding:12px;
  }
  canvas{
    width:320px; height:640px;
    background: var(--panel-dark);
    border:5px solid var(--pink);
    box-shadow:0 0 18px var(--pink);
    image-rendering: pixelated;
    outline:none;
  }
  #ui{
    display:flex;
    gap:12px;
    align-items:center;
  }
  #scoreBox{
    color: var(--accent);
    font-weight:700;
    text-align:center;
  }
  button{
    padding:6px 10px;
    border-radius:8px;
    border:2px solid var(--pink);
    background:transparent;
    color:var(--accent);
    cursor:pointer;
    font-weight:700;
  }
  button:active{ transform: translateY(1px); }
  @media(max-width:480px){
    canvas{ width:240px; height:480px; }
  }
</style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="320" height="640" tabindex="0" aria-label="Tetris game"></canvas>

    <div id="ui">
      <div id="scoreBox">
        Score: <span id="score">0</span><br>
        High: <span id="high">0</span>
      </div>

      <div id="controls">
        <button id="resetBtn">Restart</button>
        <button id="lightsBtn">Lights On</button>
      </div>
    </div>

    <div style="color:var(--accent); font-size:12px; margin-top:6px;">
      Controls: ← →  ↓ (hold) ↑ rotate • Space hard drop
    </div>
  </div>

<script>
/* ---------- SIMPLE TETRIS (stable) ---------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const highEl = document.getElementById('high');
const resetBtn = document.getElementById('resetBtn');
const lightsBtn = document.getElementById('lightsBtn');

const ROWS = 20, COLS = 10, BLOCK = 32;
const colors = ["#ff05d1","#ff70cd","#ff69ca","#f440a3","#ff007b","#ff51cb","#ff0048","#e25587","#ff309b"];
const pieces = {
  T: [[1,1,1],[0,1,0]],
  O: [[2,2],[2,2]],
  L: [[0,0,3],[3,3,3]],
  J: [[4,4,4],[0,0,4]],
  I: [[5,5,5,5]],
  S: [[0,6,6],[6,6,0]],
  Z: [[7,7,0],[0,7,7]],
};
const pieceKeys = Object.keys(pieces);

/* state */
let arena = createMatrix(ROWS,COLS);
let piece = null;
let nextPiece = null;
let score = 0;
let dropInterval = 700;
let dropCounter = 0;
let lastTime = 0;
let downPressed = false;
let highScore = parseInt(localStorage.getItem('tetris_high') || '0', 10);
highEl.textContent = highScore;

/* helpers */
function createMatrix(r,c){ return Array.from({length:r}, ()=>Array(c).fill(0)); }
function clone(m){ return m.map(row=>row.slice()); }
function randPiece(){
  const t = pieceKeys[Math.floor(Math.random()*pieceKeys.length)];
  return { type: t, matrix: pieces[t].map(r=>r.slice()), pos:{x: Math.floor((COLS - pieces[t][0].length)/2), y:0}, color: colors[Math.floor(Math.random()*colors.length)] };
}
function collide(arena, piece){
  const m = piece.matrix, o = piece.pos;
  for(let y=0;y<m.length;y++) for(let x=0;x<m[y].length;x++){
    if(m[y][x] && (arena[y+o.y] && arena[y+o.y][x+o.x]) !== 0) return true;
  }
  return false;
}
function merge(arena, piece){
  piece.matrix.forEach((row,y)=> row.forEach((v,x)=> { if(v) arena[y+piece.pos.y][x+piece.pos.x] = piece.color; }));
}
function rotate(m){
  return m[0].map((_,i)=>m.map(r=>r[i])).reverse();
}
function sweep(){
  let lines = 0;
  for(let y=arena.length-1;y>=0;y--){
    if(arena[y].every(v=>v)){
      arena.splice(y,1);
      arena.unshift(Array(COLS).fill(0));
      lines++;
    }
  }
  if(lines>0){
    score += [0,100,300,700,1500][lines] || lines*100;
    scoreEl.textContent = score;
  }
}

/* drawing */
function drawMatrix(matrix, ox, oy, blockSize, color){
  matrix.forEach((row,y)=> row.forEach((v,x)=> { if(v){ ctx.fillStyle=color; ctx.fillRect(ox + x*blockSize, oy + y*blockSize, blockSize-1, blockSize-1); }}));
}
function draw(){
  // fill background (panel)
  const panel = getComputedStyle(document.documentElement).getPropertyValue('--panel-dark')?.trim() || '#1e1e1e';
  ctx.fillStyle = panel;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // draw arena cells
  arena.forEach((row,y)=> row.forEach((val,x)=> {
    if(val){
      ctx.fillStyle = val;
      ctx.fillRect(x*BLOCK, y*BLOCK, BLOCK-1, BLOCK-1);
    } else {
      // faint grid
      ctx.strokeStyle = 'rgba(255,255,255,0.03)';
      ctx.strokeRect(x*BLOCK, y*BLOCK, BLOCK, BLOCK);
    }
  }));

  // draw current piece
  if(piece) drawMatrix(piece.matrix, piece.pos.x*BLOCK, piece.pos.y*BLOCK, BLOCK, piece.color);
}

/* game loop */
function drop(){
  piece.pos.y++;
  if(collide(arena,piece)){
    piece.pos.y--;
    merge(arena,piece);
    sweep();
    piece = nextPiece || randPiece();
    nextPiece = randPiece();
    if(collide(arena,piece)){
      // game over: update highscore, reset
      highScore = Math.max(highScore, score);
      localStorage.setItem('tetris_high', highScore);
      highEl.textContent = highScore;
      resetGame();
    }
  }
  dropCounter = 0;
}
function hardDrop(){
  while(!collide(arena,piece)) piece.pos.y++;
  piece.pos.y--;
  merge(arena,piece);
  sweep();
  piece = nextPiece || randPiece();
  nextPiece = randPiece();
}
function update(time=0){
  const delta = time - lastTime;
  lastTime = time;
  dropCounter += delta;
  if(dropCounter > (downPressed ? dropInterval/8 : dropInterval)) drop();
  draw();
  requestAnimationFrame(update);
}

/* input */
canvas.addEventListener('click', ()=> canvas.focus());
canvas.addEventListener('touchstart', ()=> canvas.focus());
canvas.focus();

document.addEventListener('keydown', e=>{
  // movement
  if(e.key === 'ArrowLeft'){ piece.pos.x--; if(collide(arena,piece)) piece.pos.x++; }
  if(e.key === 'ArrowRight'){ piece.pos.x++; if(collide(arena,piece)) piece.pos.x--; }
  if(e.key === 'ArrowDown'){ downPressed = true; }
  if(e.key === 'ArrowUp'){ const r = rotate(piece.matrix); const old = piece.matrix; piece.matrix = r; if(collide(arena,piece)) piece.matrix = old; }
  if(e.code === 'Space'){ hardDrop(); }
});
document.addEventListener('keyup', e=>{ if(e.key === 'ArrowDown') downPressed = false; });

/* UI controls */
resetBtn.addEventListener('click', ()=> { resetGame(); canvas.focus(); });
let lightsOn = false;
lightsBtn.addEventListener('click', ()=> {
  lightsOn = !lightsOn;
  if(lightsOn){
    document.body.style.background = 'var(--bg-light)';
    canvas.style.background = 'var(--panel-light)';
    lightsBtn.textContent = 'Lights Off';
  } else {
    document.body.style.background = 'var(--bg-dark)';
    canvas.style.background = 'var(--panel-dark)';
    lightsBtn.textContent = 'Lights On';
  }
});

/* init/reset */
function resetGame(){
  arena = createMatrix(ROWS,COLS);
  piece = randPiece();
  nextPiece = randPiece();
  score = 0;
  scoreEl.textContent = '0';
  dropCounter = 0;
  lastTime = performance.now();
}
resetGame();
update();
</script>
</body>
</html>
